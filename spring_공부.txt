spring framework
 
  http://spring.io  (외우기)
  http://mvnrepository.com ( Maven, Gradle 등 빌드줄의 의존성 설정정보 제공, 외우기)
     
1. 환경설정

   - JDK 1.8 ( JDK 11 )
   - tomcat 9.X
   - 개발툴: 이클립스 (X)
           STS ( Spring Tool Suite )툴 - 이클립스와 동일, tc server 내장
           sts 3.9.14 버전의 full distribution on Eclipse 4.15 다운 ( JDK 1.8 지원함 )

    * sts 3 vs sts 4
     - sts 3 :  spring framework + spring boot
     - sts 4 :  spring boot
  
   - spring framework 5.2.25.RELEASE 

2. spring 기술 종류

  가. spring framework
  나. spring boot
 
3. sts3 에서 프로젝트 생성
   
   가. Spring legacy Project
      ==>  spring framework 개발용

        1) Simple Spring Maven
           ==> standalong 어플리케이션 개발용 ( main 메서드 가짐 )
           ==> Maven 빌드툴 기반

	2) Spring MVC Project
	   ==> 웹 어플리케이션 개발용
           ==> Maven 빌드툴 기반

   나. Spring Starter Project
      ==> spring boot 개발용

4. Maven 빌드툴
  
  - 프로그램 개발 프로세스

             <-------- 과거에는 일련의 작업들을 개발자들이 수 작업 함 ------------------------->

     소스코드작성 --> 컴파일 --> 테스트파일(단위테스트) 작성 --> 컴파일 --> 패키징 (jar, war) --> 배포
             --> 만약 오라클 연동한다면
	        ojdbc6_g.jar 다운로드해서
		빌드패스 적용.
		( 필요로하는 외부 jar파일을
		  다운로드해서 빌드패스 설정)
               
	       <----- 현재는 빌드툴 자동화 ------------------------------------------------->

  * 현재 가장 많이 사용하는 빌드 툴
    가. Maven
       - pom.xml

    나. Gradle
       - build.gradle

  * Maven 프로젝트 구조

    프로젝트명
      src/main/java ==> 이전 src 경로와 동일하고 *.java 저장됨
      src/main/resource ==> *.java 제외한 나머지 자원( *.properties, *.xml ) 저장함.
                        ==> src/main/java 저장해도 무관.
			    Maven이 자동으로 src/main/resource에 있는 자원을
			    src/main/java로 복사해줌.
      src/test/java ==> 단위 테스트 용  *.java 저장됨
                    ==> Maven이 자동으로 컴파일 및 실행해줌.

      JRE System Library ==> JDK 정보
                        ==> pom.xml 파일에 다음과 같이 설정한다.
	<build>
	 <plugins>
	   <plugin>
	   <groupId>org.apache.maven.plugins</groupId>
	   <artifactId>maven-compiler-plugin</artifactId>
	   <version>3.8.0</version>
	   <configuration>
	    <source>1.8</source>
	    <target>1.8</target>
	   </configuration>
	   </plugin>
	 </plugins>
	</build>

      Maven Dependencies  ==> Maven 빌드툴이 내부적으로 관리하는 jar 파일들이 저장됨.
                         ==> 필요로 하는 jar 파일들을 pom.xml 에서 설정하면
			     자동으로 다운로드 되고 빌드패스됨. 
                         ==>   http://mvnrepository.com 설정방법 제공받을 수 있음.
                          <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
				<dependency>
				    <groupId>org.mybatis</groupId>
				    <artifactId>mybatis</artifactId>
				    <version>3.5.13</version>
				</dependency>
                         ==> a.jar ==> b.jar ==> c.jar 형태의 의존적인 관계인 경우
			   a.jar 만 지정해도 b.jar와 c.jar를 자동으로 함께 다운로드 됨.
       
      src  ==> 특별한 것 없음
      target ==> 패키징(jar, war)할 때 저장되는 곳.

      pom.xml  ==> Maven 빌드툴의 전체 설정 정보를 가짐.
               ==> 크게 2가지 관심을 갖는다.
	         a. JDK 버전
		 b. Spring Framework 버전
		   ==> http://spring.io 에서 지원 버전 확인 가능

#####################################################
5. Spring framework 개발 방법

  가) XML 이용
     ==> 초창기 버전. 거의 사용 안함.

  나) XML + 어노테이션(@ 사용) 이용
     ==> 가장 많이 사용됨.

  다) 어노테이션 이용(@ 사용, java configuration 방법이라고 부른다.)
     ==> 근래에 많이 사용되는 추세
     ==> spring boot 기반 기술


  * 코드로 배우는 스프링 웹 프로젝트 교재는 
    나) 와 다) 방법 모두 기술됨.
    예> p41, p113 보면  Java 설정을 이용하는 경우..... ( skip )


6. 비 스프링 개발  vs 스프링 개발

   가.  비 스프링 개발

        UserMain.java -------> UserService.java
        (main)                    mesg(){} 

	UserService s = new UserService();
	s.mesg();

   나. 스프링 개발

        UserMain.java -------> UserService.java
        (main)                    mesg(){} 

      - 스프링에서는 클래스를 빈(bean)이라고 부른다. 
      - 직접 빈을 new 하지 않음. 외부(*)에서 위임해서 관리 ( 빈 생성 ~ 빈 소멸, 빈의 lifecycle )
        tomcat 컨테이너가 서블릿을 관리하는 방식과 비슷하다.
	차이점은 tomcat은 서버(프로그램)이고 빈을 관리하는 외부(*)는 프로그램이 아니고 또 다른 빈이다.
        외부(*)의 실체 클래스(빈)는 ApplicatonContext 이다.
      - 작업 순서
        1) 빈을 생성( *.java)
	2) 빈을 xml에 등록 ( src/main/resource 에  user.xml 생성 )
	  ==> 빈 등록등 다양한 설정 정보를 저장할 수 있다.
	     예> mybatis의 Configuration.xml 역할이고
	        tomcat의 web.xml 역할이다.
	3) ApplicatonContext 에 xml을 알려준다.
	4) ApplicatonContext 가 xml에 등록된 빈 정보를 보고 자동생성 ~ 소멸 처리함.

      ==> 누구나 개발에도 위 순서로 개발하게 된다. ( 정형화 된 방법: 틀 )
          틀의 역할이 프레임워크(framework)이다. 유지보수 장점이 매우 크다.
	  매우 가벼운 경량의 프레임워크 이다.

#####################################################

Dependency injection (DI)
- 의존성 주입
- 개념: 특정 빈에 임의의 값을 제공하는 것을 의미한다.

    예>
        public class UserService{
             
	     int num;  <------------------ 외부(xml)에서 num 변수에 값을 제공.          

              ...
	      // 생성자 주입 ( Constructor-based Dependency injection )
	      public UserService(int num){
	        this.num= num;
	      }

	      public void setNum(int num){
  	       this.num = num;
	      }
	}

    이전방식

         UserService service = new UserService(10);
	 //service.num = 10;
	 service.setNum(10);

    스프링 방식 1
  
      가. 생성자 이용 방식 ( Constructor-based Dependency injection )
          
	  <bean id="xxx" class="com.service.UserService" />
           ==> UserService xxx = new UserService(); 동일


           <bean id="service" class="com.service.UserService" >
              <constructor-arg type="int" value="10" />
	   </bean>
           ==>UserService service = new UserService(10);


############################################################################
	      public UserSevice2(int num, String name){}

            <bean id="xxx" class="com.service.UserService2" >
              <constructor-arg type="int" value="10" />
	      <constructor-arg  value="홍길동" />
	    </bean>
<bean id="yyy" class="com.service.UserService2">
<constructor-arg name="username" value="홍길동" />
<constructor-arg name="num" value="10" />
</bean>
	    <bean id="yyy3" class="com.service.UserService2">
	      <constructor-arg index="1" value="홍길동" />
	      <constructor-arg index="0" value="10" />
	    </bean>
           ==>UserService2 xxx = new UserService2(10,"홍길동");


   주입할 데이터 값이 기본형(int,float..)과 문자열인 경우에는  value 속성을 사용한다.
   <constructor-arg  value="기본값|문자열" />
   만약 주입할 값이 참조형(문자열제외)인 경우에는 ref 속성을 사용한다.
//////////////////////////////////////////////////////////
   UserService3, UserDAO

      public class UserService3 {

	    UserDAO dao;
	
	  public UserService3(UserDAO dao){
	    this.dao = dao;
          }
      }
     <!-- UserDao dao = new UserDAO(); -->
     <bean id="dao" class="com.dao.UserDAO" /> 

     <!-- UserService3 service = new UserService3(dao); -->
     <bean id="service" class="com.service.UserService3" >
        <constructor-arg  ref="dao"  />
     </bean>

###################################################################

      나. set메서드 이용 방식 ( Setter-based Dependency injection )
   
          public class UserService{
             
	     int num;  <------------------ 외부(xml)에서 num 변수에 값을 제공.          
              
	      // setter 메서드 이용
   	      public void setNum(int num){
  	       this.num = num;
	      }
	}

       이전방식

         UserService service = new UserService();
	 service.setNum(10);

  
      스프링
          <bean id="service" class="com.service.UserService" >
             <property  name="num"  value="10" /> num은 setNum 메서드를 찾음.
          </bean>

#################################################################
스프링에서 의존성 주입

1) 스프링 방식 1 - 태그 이용
    가. 생성자 이용
           <bean id="service" class="com.service.UserService" >  
        -     <constructor-arg >
    나. set메서드 이용
            <bean id="service" class="com.service.UserService" >
        -     <property >


2) 스프링 방식 2 - namespace 의 속성 이용 
      
      
    가. 생성자 이용
    ( 반드시 xmlns:c="http://www.springframework.org/schema/c" 추가해야 된다. )
         <bean id="service" class="com.service.UserService" 
	  c:생성자의변수명="값"  c:생성자의변수명-ref="값"    />

    나. set메서드 이용
      (반드시  xmlns:p="http://www.springframework.org/schema/p"  추가해야 된다. )
         <bean id="service" class="com.service.UserService" 
	 p:set메서드명="값" p:set메서드명-ref="값"/>

##########################################################
스프링에서 컬렉션 의존성 주입

1) list 주입
    - 자바코드: List<Cat> catList;
    - xml : 
         <property name="catList">
              <list>
                 <ref bean="값1" />
		 <ref bean="값2" />
	      </list>
	 </property>
  
2) set 주입
    - 자바코드: Set<Cat> catSet;
    - xml : 
         <property name="catSet">
              <set>
                 <ref bean="값1" />
		 <ref bean="값2" />
	      </set>
	 </property>

3) map 주입 ==> key/value 쌍으로 저장 , 저장하는 value값의 제한이 없다.
    - 자바코드: Map<String,Cat> catMap;
    - xml : 
         <property name="catMap">
              <map>
                 <entry key="" value-ref="값" />
                 <entry key="">
                    <ref bean="값" />
		 </entry>
	      </map>
	 </property>


4) props 주입 ==> key/value 쌍으로 저장, 저장하는 value값이 무조건 문자열이다.
    - 자바코드: Properties xxx;
    - xml : 
         <property name="xxx">
              <props>
                <prop key="키">문자열값</prop>
              </props>
	 </property>

####################################################################
빈 생성 관련 life cycle 콜백 메서드
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-combined-effects
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations
1. 서블릿의 life cycle 비슷
   - init() : 서블릿이 생성될 때
   - doGet/doPost : 서블릿 요청할 때
   - destroy()   : 서블릿이 삭제될 때
   
2. 빈 생성시 관련되는 콜백 메서드
  
   가. <bean id="" class="" init-method="메서드명" destroy-method="메서드" />
   나. 빈 implments InitializingBean, DisposableBean {}
   다. 어노테이션 이용: @PostConstruct , @PreDestroy ==> JDK 11부터 지원 안됨.
      반드시 어노테이션을 활성화해야 된다. ==> context namespace 이용
        <!--  빈의 어노테이션 활성화 -->
         <context:annotation-config />

#########################################################
현재 실행중인 운영체제의 환경변수 값 살펴보기
1. 일반 자바 클래스 이용
   	//1. 일반 자바 클래스
		Properties props = System.getProperties();
		Set<String> keys = props.stringPropertyNames();
		for (String key : keys) {
			System.out.println(key + "\t" + props.getProperty(key));
		}
2. 스프링 이용
   //2. 스프링
		GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
		ConfigurableEnvironment env  = ctx.getEnvironment();
		
		 Map<String, Object> m = env.getSystemProperties();
		 Set<String> keys2 = m.keySet();
		 for (String key : keys2) {
			 System.out.println(key + "\t" + m.get(key));
		}
#########################################################
Profile
개발시 환경을 다르게 구축한다. ( developement 환경,  production 환경 )

             developement 환경
 TestMain ------------> UserService_Dev 
                        (user_dev.xml, <beans profile="dev" ..> )

             production 환경
          ------------> UserService_Prod
	                (user_prod.xml <beans profile="prod" ..> )


	      UserService 인터페이스
	      |               |
	  UserService_Dev    UserService_Prod
#########################################################
Mybatis 할 때 jdbc.properties 에 4가지 정보 설정하고 Configuration.xml에 불러와서 사용했음.

스프링에서 jdbc.properties 내용 불러오기
가. jdbc.properties
나. user.xml 등록

    <!-- deprecated 됨 --> 
    <bean class="PropertyPlaceholderConfigurer">
      <property name="location"  value="classpath:com/config/jdbc.properties" />
    </bean>
    또는
    context namespace 사용 ( 기억할 것 )
    <context:property-placeholder location="classpath:com/config/jdbc.properties"/>

다. 임의의 빈에서 ${key} 방법으로 값을 얻을 수 있다.  
    <bean id="service" class="com.service.UserService">
      <property name="driver" value="${jdbc.driver}" />
      <property name="url" value="${jdbc.url}" />
      <property name="userid" value="${jdbc.username}" />
      <property name="passwd" value="${jdbc.password}" />
   </bean>
 
 ######################################################################
 I18N - 국제화 (지역화 )
 InternationalizatioN
 https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource
 가. 파일명_국가별언어코드.properties
 
    한국어 버전
    shop_ko.properties
      ==>greeting=안녕하세요

    영어 버전
    shop_en.properties
      ==>greeting=hello

    나중에 실제로 등록할 때는  shop.properties 만 등록한다.

 나. user.xml 에 등록 ( 주의할 점은 반드시 id값이  "messageSource" 이고 확장자는 지정안함)
    <bean id="messageSource" 
    class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
      <property name="basename" value="classpath:com/config/shop" />
       <!-- properties 파일을 utf-8로 저장한 경우에 사용 -->
      <property name="defaultEncoding" value="utf-8" />
   </bean>

 다. 반드시 ApplicationContext를 가진 곳에서 사용이 가능하다. ==> TestMain.java에서 사용가능.

      BeanFactory      MessageSource
               |           | 
           ApplicationContext (인터페이스)
                          |
                  WebApplicationContext ( 웹 어플리케이셔 환경 )

                |
	  GenericXmlApplicationContext (클래스)
	  ClassPathXmlApplicationContext (클래스)

####################################################
TestMain이 아닌 일반클래스(빈, UserService)에서 사용하는 방법.
"
You can also use the MessageSourceAware interface to acquire a reference 
to any MessageSource that has been defined. Any bean that is defined in 
an ApplicationContext that implements the MessageSourceAware interface 
is injected with the application context’s MessageSource when the bean 
is created and configured."

  가. UserService implements MessageSourceAware
  나.  @Override
      public void setMessageSource(MessageSource xxx){
         String mesg = xxx.getMessage("greeting", ~~~ );
	 
      }
      재정의하면 자동으로 setMessageSource메서드의 파라미터로 MessageSource(ApplicationContext)가
      자동으로 주입된다.


 * I18N 사용할 수 있는 곳 3군데
 1) TestMain
    MessageSource  ctx = new GenericXmlApplicationContext("classpath:com/config/user.xml");

 2) 임의의 빈
   - implements MessageSourceAware 
   - setMessageSource(MessageSource xxx) 재정의

 3) jsp
  - 나중에 확인하기

############################################################
bean scope
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-factory-scopes

scope 설정가능한 값
1. scope="singleton"  (기본)
   ==> 빈을 한번만 생성하고 재사용함.

2. scope="prototype"
   ==> 빈을 매번 생성

3. scope="request"
   ==> 웹 환경의 request scope와 일치

4. scope="session"
   ==> 웹 환경의 session scope와 일치

5. scope="application"
   ==> 웹 환경의 application scope와 일치

6. scope="websocket"
   ==> 웹 환경의 websocket 연동시 필요
   ==> 클라이언트와 서버가 계속 연결 유지

############################################################

어노테이션 + 최소한의 XML  Configuration Metadata 설정방법

==> 반드시 <context:annotation-config /> 지정해야 된다.

1. @Required
  - spring 5.X deprecated.

2. @Autowired ( byType 이용 )
  - 자동으로 주입
  - 주입받는 대상을 타입(type)으로 찾아서 자동 주입.
  - 사용위치 3가지
    가. 변수 ( 권장 )
    나. 생성자
    다. 메서드
  
  - 주입해야 되는 빈은 반드시 존재해야 된다. 없으면 NoSuchBeanDefinitionException 발생된다.
    비활성화 가능하다.  @Autowired(required=false)

  - 타입(type)으로 찾아서 주입하기 때문에 만약 동일한 타입이 여러개 인 경우에는
    NoUniqueBeanDefinitionException 발생된다.

    해결: 
      가.  @Autowired
          @Qualifier(value="id값")

      나. CoC (Convention over Configuration)
         - 설정정보보다 뛰어넘은 관례로 처리하는 개념을 의미한다.

	 @Autowired
	Cat cat; ==> xml에 cat과 일치하는 id를 가진 빈으로 주입이 된다.
     
        <bean id="cat" >
	<bean id="cat1"
#####################

3. @Resource  ( byName 이용 )
 
  - javax.annotation.Resource ( 스프링 라이브러리가 아님 )
  - 기능 : 빈의 타입(type)이 아닌 빈의 이름(name,id)으로 찾아서 자동으로 주입된다.

        @Autowired
        @Qualifier(value="id값")  와 동일

     
   - 문법:
         @Resource(name = "cat2")  // id="cat2" 인 빈이 주입된다.
	  Cat cat;

#####################

4. @Value
 - 기능 : 빈의 변수에 값을 설정하는 용도
 - 문법:
        @Value(value="값")
	String username;

 - 리소스번들에서 값을 가져와서 @Value에 설정하는 작업이 일반적임.

     application.properties 파일
        jdbc.userid=aaa

     user.xml 파일
         <context:property-placeholder location="classpath:com/config/application.properties" >

     빈 파일
	 @Value(value="${jdbc.userid}")
	  String userid;

######################################################

5. SpEL ( Spring Framework Expression Language )
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#expressions-beandef-xml-based

  - 기능:  xml파일에서 속성값을 #{표현식} 이용해서 설정.
  - 표현식: 일반 값 ( 문자열, 숫자등 )
          연산자(산술, 비교)
          리소스 번들에서 값 얻기
	  빈의 메서드 호출 ( 인스턴스 메서드, static 메서드 )
	  컬렉션 사용

 ################################
 JSON
 
   var m = {"id":"aa","pw":1234};
   
   console.log( m.id,  m.pw );   // 변수 사용 불가

   console.log( m["id"],  m["pw"] );   // 연관배열, 장점은 변수를 사용할 수 있다.

   var x = "id";
   console.log( m[x],  m["pw"] );
 #################################### 
