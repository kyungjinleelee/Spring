spring framework
 
  http://spring.io  (외우기)
  http://mvnrepository.com ( Maven, Gradle 등 빌드줄의 의존성 설정정보 제공, 외우기)
     
1. 환경설정

   - JDK 1.8 ( JDK 11 )
   - tomcat 9.X
   - 개발툴: 이클립스 (X)
           STS ( Spring Tool Suite )툴 - 이클립스와 동일, tc server 내장
           sts 3.9.14 버전의 full distribution on Eclipse 4.15 다운 ( JDK 1.8 지원함 )

    * sts 3 vs sts 4
     - sts 3 :  spring framework + spring boot
     - sts 4 :  spring boot
  
   - spring framework 5.2.25.RELEASE 

2. spring 기술 종류

  가. spring framework
  나. spring boot
 
3. sts3 에서 프로젝트 생성
   
   가. Spring legacy Project
      ==>  spring framework 개발용

        1) Simple Spring Maven
           ==> standalong 어플리케이션 개발용 ( main 메서드 가짐 )
           ==> Maven 빌드툴 기반

	2) Spring MVC Project
	   ==> 웹 어플리케이션 개발용
           ==> Maven 빌드툴 기반

   나. Spring Starter Project
      ==> spring boot 개발용

4. Maven 빌드툴
  
  - 프로그램 개발 프로세스

             <-------- 과거에는 일련의 작업들을 개발자들이 수 작업 함 ------------------------->

     소스코드작성 --> 컴파일 --> 테스트파일(단위테스트) 작성 --> 컴파일 --> 패키징 (jar, war) --> 배포
             --> 만약 오라클 연동한다면
	        ojdbc6_g.jar 다운로드해서
		빌드패스 적용.
		( 필요로하는 외부 jar파일을
		  다운로드해서 빌드패스 설정)
               
	       <----- 현재는 빌드툴 자동화 ------------------------------------------------->

  * 현재 가장 많이 사용하는 빌드 툴
    가. Maven
       - pom.xml

    나. Gradle
       - build.gradle

  * Maven 프로젝트 구조

    프로젝트명
      src/main/java ==> 이전 src 경로와 동일하고 *.java 저장됨
      src/main/resource ==> *.java 제외한 나머지 자원( *.properties, *.xml ) 저장함.
                        ==> src/main/java 저장해도 무관.
			    Maven이 자동으로 src/main/resource에 있는 자원을
			    src/main/java로 복사해줌.
      src/test/java ==> 단위 테스트 용  *.java 저장됨
                    ==> Maven이 자동으로 컴파일 및 실행해줌.

      JRE System Library ==> JDK 정보
                        ==> pom.xml 파일에 다음과 같이 설정한다.
	<build>
	 <plugins>
	   <plugin>
	   <groupId>org.apache.maven.plugins</groupId>
	   <artifactId>maven-compiler-plugin</artifactId>
	   <version>3.8.0</version>
	   <configuration>
	    <source>1.8</source>
	    <target>1.8</target>
	   </configuration>
	   </plugin>
	 </plugins>
	</build>

      Maven Dependencies  ==> Maven 빌드툴이 내부적으로 관리하는 jar 파일들이 저장됨.
                         ==> 필요로 하는 jar 파일들을 pom.xml 에서 설정하면
			     자동으로 다운로드 되고 빌드패스됨. 
                         ==>   http://mvnrepository.com 설정방법 제공받을 수 있음.
                          <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
				<dependency>
				    <groupId>org.mybatis</groupId>
				    <artifactId>mybatis</artifactId>
				    <version>3.5.13</version>
				</dependency>
                         ==> a.jar ==> b.jar ==> c.jar 형태의 의존적인 관계인 경우
			   a.jar 만 지정해도 b.jar와 c.jar를 자동으로 함께 다운로드 됨.
       
      src  ==> 특별한 것 없음
      target ==> 패키징(jar, war)할 때 저장되는 곳.

      pom.xml  ==> Maven 빌드툴의 전체 설정 정보를 가짐.
               ==> 크게 2가지 관심을 갖는다.
	         a. JDK 버전
		 b. Spring Framework 버전
		   ==> http://spring.io 에서 지원 버전 확인 가능

#####################################################
5. Spring framework 개발 방법

  가) XML 이용
     ==> 초창기 버전. 거의 사용 안함.

  나) XML + 어노테이션(@ 사용) 이용
     ==> 가장 많이 사용됨.

  다) 어노테이션 이용(@ 사용, java configuration 방법이라고 부른다.)
     ==> 근래에 많이 사용되는 추세
     ==> spring boot 기반 기술


  * 코드로 배우는 스프링 웹 프로젝트 교재는 
    나) 와 다) 방법 모두 기술됨.
    예> p41, p113 보면  Java 설정을 이용하는 경우..... ( skip )


6. 비 스프링 개발  vs 스프링 개발

   가.  비 스프링 개발

        UserMain.java -------> UserService.java
        (main)                    mesg(){} 

	UserService s = new UserService();
	s.mesg();

   나. 스프링 개발

        UserMain.java -------> UserService.java
        (main)                    mesg(){} 

      - 스프링에서는 클래스를 빈(bean)이라고 부른다. 
      - 직접 빈을 new 하지 않음. 외부(*)에서 위임해서 관리 ( 빈 생성 ~ 빈 소멸, 빈의 lifecycle )
        tomcat 컨테이너가 서블릿을 관리하는 방식과 비슷하다.
	차이점은 tomcat은 서버(프로그램)이고 빈을 관리하는 외부(*)는 프로그램이 아니고 또 다른 빈이다.
        외부(*)의 실체 클래스(빈)는 ApplicatonContext 이다.
      - 작업 순서
        1) 빈을 생성( *.java)
	2) 빈을 xml에 등록 ( src/main/resource 에  user.xml 생성 )
	  ==> 빈 등록등 다양한 설정 정보를 저장할 수 있다.
	     예> mybatis의 Configuration.xml 역할이고
	        tomcat의 web.xml 역할이다.
	3) ApplicatonContext 에 xml을 알려준다.
	4) ApplicatonContext 가 xml에 등록된 빈 정보를 보고 자동생성 ~ 소멸 처리함.

      ==> 누구나 개발에도 위 순서로 개발하게 된다. ( 정형화 된 방법: 틀 )
          틀의 역할이 프레임워크(framework)이다. 유지보수 장점이 매우 크다.
	  매우 가벼운 경량의 프레임워크 이다.

#####################################################

Dependency injection (DI)
- 의존성 주입
- 개념: 특정 빈에 임의의 값을 제공하는 것을 의미한다.

    예>
        public class UserService{
             
	     int num;  <------------------ 외부(xml)에서 num 변수에 값을 제공.          

              ...
	      // 생성자 주입 ( Constructor-based Dependency injection )
	      public UserService(int num){
	        this.num= num;
	      }

	      public void setNum(int num){
  	       this.num = num;
	      }
	}

    이전방식

         UserService service = new UserService(10);
	 //service.num = 10;
	 service.setNum(10);

    스프링 방식 1
  
      가. 생성자 이용 방식 ( Constructor-based Dependency injection )
          
	  <bean id="xxx" class="com.service.UserService" />
           ==> UserService xxx = new UserService(); 동일


           <bean id="service" class="com.service.UserService" >
              <constructor-arg type="int" value="10" />
	   </bean>
           ==>UserService service = new UserService(10);


############################################################################
	      public UserSevice2(int num, String name){}

            <bean id="xxx" class="com.service.UserService2" >
              <constructor-arg type="int" value="10" />
	      <constructor-arg  value="홍길동" />
	    </bean>
<bean id="yyy" class="com.service.UserService2">
<constructor-arg name="username" value="홍길동" />
<constructor-arg name="num" value="10" />
</bean>
	    <bean id="yyy3" class="com.service.UserService2">
	      <constructor-arg index="1" value="홍길동" />
	      <constructor-arg index="0" value="10" />
	    </bean>
           ==>UserService2 xxx = new UserService2(10,"홍길동");


   주입할 데이터 값이 기본형(int,float..)과 문자열인 경우에는  value 속성을 사용한다.
   <constructor-arg  value="기본값|문자열" />
   만약 주입할 값이 참조형(문자열제외)인 경우에는 ref 속성을 사용한다.
//////////////////////////////////////////////////////////
   UserService3, UserDAO

      public class UserService3 {

	    UserDAO dao;
	
	  public UserService3(UserDAO dao){
	    this.dao = dao;
          }
      }
     <!-- UserDao dao = new UserDAO(); -->
     <bean id="dao" class="com.dao.UserDAO" /> 

     <!-- UserService3 service = new UserService3(dao); -->
     <bean id="service" class="com.service.UserService3" >
        <constructor-arg  ref="dao"  />
     </bean>

###################################################################

      나. set메서드 이용 방식 ( Setter-based Dependency injection )
   
          public class UserService{
             
	     int num;  <------------------ 외부(xml)에서 num 변수에 값을 제공.          
              
	      // setter 메서드 이용
   	      public void setNum(int num){
  	       this.num = num;
	      }
	}

       이전방식

         UserService service = new UserService();
	 service.setNum(10);

  
      스프링
          <bean id="service" class="com.service.UserService" >
             <property  name="num"  value="10" /> num은 setNum 메서드를 찾음.
          </bean>

#################################################################
스프링에서 의존성 주입

1) 스프링 방식 1 - 태그 이용
    가. 생성자 이용
           <bean id="service" class="com.service.UserService" >  
        -     <constructor-arg >
    나. set메서드 이용
            <bean id="service" class="com.service.UserService" >
        -     <property >


2) 스프링 방식 2 - namespace 의 속성 이용 
      
      
    가. 생성자 이용
    ( 반드시 xmlns:c="http://www.springframework.org/schema/c" 추가해야 된다. )
         <bean id="service" class="com.service.UserService" 
	  c:생성자의변수명="값"  c:생성자의변수명-ref="값"    />

    나. set메서드 이용
      (반드시  xmlns:p="http://www.springframework.org/schema/p"  추가해야 된다. )
         <bean id="service" class="com.service.UserService" 
	 p:set메서드명="값" p:set메서드명-ref="값"/>

##########################################################
스프링에서 컬렉션 의존성 주입

1) list 주입
    - 자바코드: List<Cat> catList;
    - xml : 
         <property name="catList">
              <list>
                 <ref bean="값1" />
		 <ref bean="값2" />
	      </list>
	 </property>
  
2) set 주입
    - 자바코드: Set<Cat> catSet;
    - xml : 
         <property name="catSet">
              <set>
                 <ref bean="값1" />
		 <ref bean="값2" />
	      </set>
	 </property>

3) map 주입 ==> key/value 쌍으로 저장 , 저장하는 value값의 제한이 없다.
    - 자바코드: Map<String,Cat> catMap;
    - xml : 
         <property name="catMap">
              <map>
                 <entry key="" value-ref="값" />
                 <entry key="">
                    <ref bean="값" />
		 </entry>
	      </map>
	 </property>


4) props 주입 ==> key/value 쌍으로 저장, 저장하는 value값이 무조건 문자열이다.
    - 자바코드: Properties xxx;
    - xml : 
         <property name="xxx">
              <props>
                <prop key="키">문자열값</prop>
              </props>
	 </property>

####################################################################

